# Модули и пакеты в Python

В этой статье рассматриваются __модули__ и __пакеты__ в Python, два механизма, которые упрощают модульное программирование.

__Модульное программирование__ относится к процессу разделения большой, громоздкой задачи программирования на отдельные, более мелкие, более управляемые подзадачи или __модули__. Затем отдельные модули могут быть собраны вместе, как строительные блоки, для создания более крупного приложения.

Модульность кода в большом приложении дает несколько преимуществ:

- __Простота__: вместо того, чтобы сосредотачиваться на всей проблеме, отдельный модуль обычно фокусируется на одной относительно небольшой части проблемы. Если вы работаете над одним модулем, у вас будет меньшая решаемая задача. Это упрощает разработку и снижает вероятность появления ошибок.

- __Поддержка__: модули обычно проектируются с четкими логическими границами между разными частями программы. Если модули написаны таким образом, это уменьшает взаимозависимость и вероятность появления ошибок при последующих изменения в программе. Вы даже можете вносить изменения в модуль, не зная о приложении вне этого модуля. Это дает возможность одновременной работе команде программистов, которые разрабатывают один проект.

- __Возможность повторного использования__: Функциональность, определенная в одном модуле, может быть легко повторно использована (через должным образом определенный интерфейс) другими частями приложения. Это избавляет от необходимости дублировать код.

- __Область использования__: модули обычно определяют отдельное пространство имен, что помогает избежать конфликтов между идентификаторами в разных областях программы. (Один из постулатов дзен Python заключается в том, что _пространства имен - это отличная идея - давайте сделаем их больше!_).

__Функции__, __модули__ и __пакеты__ - все это конструкции в Python, которые способствуют модульности кода.

## Модули Python: Обзор

На самом деле существует три разных способа определить __модуль__ в Python:

1. Модуль может быть написан на самом Python.
2. Модуль может быть написан на __C__ и загружен динамически во время выполнения, как модуль re( регулярное выражение ).
3. Встроенный модуль структурно содержится в интерпретаторе, как _itertools_ модуль .

Получение доступа к содержимому модуля во всех трех случаях осуществляется одинаково: с помощью оператора __import__.

В статье основное внимание будет уделено модулям, написанным на Python. Самое замечательное в модулях, написанных на Python, заключается в том, что их чрезвычайно просто создать. Все, что вам нужно сделать, это создать файл, содержащий  код Python, а затем дать этому файлу имя с `.py` расширением. Вот и все! Никакого специального синтаксиса или колдовства не требуется.

Например, предположим, что мы создали файл с именем, `mod.py` содержащий следующий код:

```python
s = "If Comrade Napoleon says it, it must be right."
a = [100, 200, 300]

def foo(arg):
    print(f'arg = {arg}')

class Foo:
    pass
```

Некоторые объекты определенные в mod.py:

- s (a string)
- a (a list)
- foo() (a function)
- Foo (a class)
  
Предполагая, что файл (модуль) _mod.py_ находятся в подходящем месте в файловой системе компьютера, о котором мы поговорим чуть позже, к объектам модуля можно получить доступ, импортировав модуль следующим образом:

```python
>>> import mod
>>> print(mod.s)
If Comrade Napoleon says it, it must be right.
>>> mod.a
[100, 200, 300]
>>> mod.foo(['quux', 'corge', 'grault'])
arg = ['quux', 'corge', 'grault']
>>> x = mod.Foo()
>>> x
<mod.Foo object at 0x03C181F0>
```

## The Module Search Path

Продолжая приведенный выше пример, давайте посмотрим, что происходит, когда Python выполняет строку с оператором _import_:

```python
import mod
```

Когда интерпретатор выполняет вышеуказанный _import_ оператор, он ищет модуль _mod.py_ в списке директорий (мест), собранных из следующих источников:

- Директория, из которой был запущен входной сценарий, или текущий каталог, если интерпретатор запускается в интерактивном режиме.
- Список директорий, содержащихся в [PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) переменной окружения, если она установлена. (Формат для PYTHONPATH зависит от ОС, но должен имитировать PATH переменную среды.)
- Зависящий от установки список директорий, настроенный во время установки Python.
- 
Итоговый список всех директорий (путей), в которых ведется поиск модулей, доступен в переменной Python `sys.path` из модуля __sys__:

```python
>>> import sys
>>> sys.path
['', 'C:\\Users\\john\\Documents\\Python\\doc', 'C:\\Python36\\Lib\\idlelib',
'C:\\Python36\\python36.zip', 'C:\\Python36\\DLLs', 'C:\\Python36\\lib',
'C:\\Python36', 'C:\\Python36\\lib\\site-packages']
```

> __Примечание__: точное значение переменной _sys.path_ зависит от параметров установки Python на вашем компьютере и ОС. Вышеупомянутый список путей наверняка будет выглядеть немного иначе на вашем компьютере.

Таким образом, чтобы убедиться, что ваш модуль найден, вам необходимо выполнить одно из следующих действий:

- Поместите _mod.py_ в каталог, в котором находится входной скрипт (исполняемый файл Python), или в текущий каталог, откуда мы заходим в интерактивный режим (Python Shell).
- Измените PYTHONPATH переменную среды, чтобы она содержала каталог, в котором расположен модуль _mod.py_, перед запуском интерпретатора.
- Поместите модуль _mod.py_ в один из каталогов переменной PYTHONPATH.

На самом деле есть одна дополнительная возможность: вы можете поместить файл модуля в любой каталог по вашему выбору, а затем изменить _sys.path_ во время выполнения, чтобы он содержал этот каталог. Например, в этом случае вы можете поместить модуль _mod.py_ в каталог, _C:\Users\johnа_ затем выполнить следующие выражения:

```python
>>> sys.path.append(r'C:\Users\john')
>>> sys.path
['', 'C:\\Users\\john\\Documents\\Python\\doc', 'C:\\Python36\\Lib\\idlelib',
'C:\\Python36\\python36.zip', 'C:\\Python36\\DLLs', 'C:\\Python36\\lib',
'C:\\Python36', 'C:\\Python36\\lib\\site-packages', 'C:\\Users\\john']
>>> import mod
```

После того, как модуль был импортирован, мы можем определить его расположение в файловой системе с помощью `__file__` атрибута импортированного модуля:

```python
>>> import mod
>>> mod.__file__
'C:\\Users\\john\\mod.py'

>>> import re
>>> re.__file__
'C:\\Python36\\lib\\re.py'
```

## Оператор import

Содержимое модуля становится доступным для вызывающего абонента с помощью _import_ оператора. Выражение с оператором _import_ имеет несколько вариантов использования. Рассмотрим их по отдельности.

## import <module_name>

С данным выражением мы уже сталкивались в примерах выше:

```python
import <module_name>
```

Обратите внимание, что это не делает содержимое модуля напрямую вызываемым. Каждый модуль имеет свою собственную частную таблицу символов, которая служит глобальной таблицей символов для всех объектов, определенных в модуле. Таким образом, как уже отмечалось, модуль имеет отдельное пространство имен.

Оператор `import <module_name>` помещает <module_name> в вызывающую символьную таблицу. Объекты, определенные в модуле остаются в частной таблице символов модуля.

Из вызывающего объекта объекты в модуле доступны только в том случае, если они имеют префикс <module_name>, соединенный через точку, как показано ниже.

После следующего _import_ оператора модуль _mod_ помещается в локальную таблицу символов:

```python
>>> import mod
>>> mod
<module 'mod' from 'C:\\Users\\john\\Documents\\Python\\doc\\mod.py'>
```

Но `s` и `foo` остаются в пространстве имен модуля и не могут быть вызваны напрямую

```python
>>> s
NameError: name 's' is not defined
>>> foo('quux')
NameError: name 'foo' is not defined
```

Для доступа к объектам их имена должны иметь префикс _mod_:

```python
>>> mod.s
'If Comrade Napoleon says it, it must be right.'
>>> mod.foo('quux')
arg = quux
```

В одном выражении с оператором _import_ можно указать несколько модулей, разделенных запятыми:

```python
import <module_name>[, <module_name> ...]
```

## from <module_name> import <name(s)>

Альтернативная форма _import_ выражения позволяет импортировать отдельные объекты из модуля непосредственно в таблицу символов вызывающего объекта:

```python
from <module_name> import <name(s)>
```

После выполнения вышеуказанного выражения объекты _<name(s)>_ доступны без _<module_name>_ префикса:

```python
>>> from mod import s, foo
>>> s
'If Comrade Napoleon says it, it must be right.'
>>> foo('quux')
arg = quux

>>> from mod import Foo
>>> x = Foo()
>>> x
<mod.Foo object at 0x02E3AD50>
```

В таком формате выражения _import_ имена объектов помещаются непосредственно в таблицу символов вызывающего объекта, любые объекты, которые уже существуют с такими же именами, будут перезаписаны:

```python
>>> a = ['foo', 'bar', 'baz']
>>> a
['foo', 'bar', 'baz']

>>> from mod import a
>>> a
[100, 200, 300]
```

Можно извлечь все содержимое модуля с помощью следующего выражения:

```python
from <module_name> import *
```

Это поместит имена всех объектов из _<module_name>_ в локальную таблицу символов, за исключением тех, которые начинаются с символа `_` нижнего подчеркивания.

```python
>>> from mod import *
>>> s
'If Comrade Napoleon says it, it must be right.'
>>> a
[100, 200, 300]
>>> foo
<function foo at 0x03B449C0>
>>> Foo
<class 'mod.Foo'>
```

Такого рода импорты не рекомендуется. Это немного опасно, потому что мы массово вводите имена в локальную таблицу символов. Если мы не знаем их все хорошо и не уверены, что конфликта не будет, у нас есть шанс случайно перезаписать существующие имена. Однако этот синтаксис очень удобен, когда вы просто работаете с интерактивным интерпретатором для целей тестирования или изучения, потому что он предоставляет вам доступ ко всему, что может предложить модуль, с меньшим набором текста.

## from <module_name> import <name> as <alt_name>

Также можно импортировать отдельные объекты, но вводить их в локальную таблицу символов с альтернативными именами:

```python
from <module_name> import <name> as <alt_name>[, <name> as <alt_name> …]
```

Это позволяет помещать имена непосредственно в локальную таблицу символов, но избегать конфликтов с ранее существовавшими именами или использовать более удобные и подходящие имена:

```python
>>> s = 'foo'
>>> a = ['foo', 'bar', 'baz']

>>> from mod import s as string, a as alist
>>> s
'foo'
>>> string
'If Comrade Napoleon says it, it must be right.'
>>> a
['foo', 'bar', 'baz']
>>> alist
[100, 200, 300]
```

```python

```

```python

```

```python

```

```python

```

> Перевод статьи: [Python Modules and Packages](https://realpython.com/python-modules-packages/).