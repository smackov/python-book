# Тестирование с помощью модуля Pytest

Сегодня тестирование приложений стало стандартным набором навыков, необходимым для любого компетентного разработчика. Общинные объятия Python тестирования , и даже стандартная библиотека Python имеет хорошие инструменты встроенные к тестированию поддержки. В более крупной экосистеме Python есть множество инструментов для тестирования. Pytest выделяется среди них своей простотой использования и способностью справляться со все более сложными задачами тестирования.

В этом руководстве будет показано, как писать тесты для кода Python с помощью pytest и как использовать его для обслуживания широкого спектра сценариев тестирования.

# Пример использования

Начнем с простого теста. Pytest ожидает, что наши тесты будут расположены в файлах, имена которых начинаются `test_` или заканчиваются на `_test.py`.

Давайте создадим файл с именем `test_capitalize.py`, и внутри него мы напишем функцию с именем `capital_case`, которая должна принимать строку в качестве аргумента и должна возвращать версию строки с заглавной буквы.

Мы также напишем тест, `test_capital_case` чтобы убедиться, что функция выполняет то, что должна делать. Мы будем ставить `test_` перед именами наших тестовых функций префикс , так как pytest ожидает, что наши тестовые функции будут названы именно так.

```python
# test_capitalize.py

def capital_case(x):
    return x.capitalize()

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'
```

Сразу бросается в глаза то, что pytest использует простой оператор assert, который намного проще запомнить и использовать по сравнению с многочисленными `assertSomething` функциями, найденными в `unittest`.

Чтобы запустить тест, выполните `pytest` команду:

```bash
$ pytest
```

Мы должны убедиться, что наш первый тест пройден.

Внимательный читатель заметит, что наша функция может привести к ошибке. Он не проверяет тип аргумента, чтобы убедиться, что это строка. Следовательно, если мы передадим число в качестве аргумента функции, это вызовет исключение.

Мы хотели бы обработать этот случай в нашей функции, вызвав настраиваемое исключение с понятным сообщением об ошибке для пользователя.

Попробуем зафиксировать это в нашем тесте:

```python
# test_capitalize.py

import pytest

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'

def test_raises_exception_on_non_string_arguments():
    with pytest.raises(TypeError):
        capital_case(9)
```

Основным дополнением здесь является `pytest.raises` помощник, который утверждает, что наша функция должна вызывать a `TypeError` в случае, если переданный аргумент не является строкой.

Запуск тестов на этом этапе должен завершиться ошибкой со следующей ошибкой:

```python
def capital_case(x):
>       return x.capitalize()
E       AttributeError: 'int' object has no attribute 'capitalize'
```

Поскольку мы убедились, что не рассматривали такой случай, мы можем исправить это.

В нашей `capital_case` функции мы должны проверить, является ли переданный аргумент строкой или подклассом строки, прежде чем вызывать `capitalize` функцию. Если это не так, мы должны создать `TypeError` специальное сообщение об ошибке.

```python
# test_capitalize.py

def capital_case(x):
    if not isinstance(x, str):
        raise TypeError('Please provide a string argument')
      return x.capitalize()
```

Когда мы перезапустим наши тесты, они должны снова пройти.

# Использование Pytest Fixtures

```python

```

```python

```

```python

```

```python

```

```python

```

```python

```

```python

```

```python

```

```python

```

> Первод статьи [Testing Python Applications with Pytest](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest)
