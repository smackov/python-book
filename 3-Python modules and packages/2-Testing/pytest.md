# Тестирование с помощью модуля Pytest

Сегодня тестирование приложений стало стандартным навыком, необходимым для любого компетентного разработчика. Существует много пакетов Python для тестирования, и даже стандартная библиотека Python имеет хорошие инструменты для тестирования. В более крупной экосистеме Python есть множество инструментов для тестирования. Pytest выделяется среди них своей простотой использования и способностью справляться со все более сложными задачами тестирования.

В этом руководстве будет показано, как писать тесты для кода Python с помощью pytest и как использовать его для обслуживания широкого спектра сценариев тестирования.

# Пример использования

Начнем с простого теста. Pytest ожидает, что наши тесты будут расположены в файлах, имена которых начинаются `test_` или заканчиваются на `_test.py`.

Давайте создадим файл с именем `test_capitalize.py`, и внутри него мы напишем функцию с именем `capital_case`, которая должна принимать строку в качестве аргумента и должна возвращать версию строки с заглавной буквы.

Мы также напишем тест, `test_capital_case` чтобы убедиться, что функция выполняет то, что должна делать. Мы будем ставить префикс `test_` перед именами всех тестовых функций, так как pytest ожидает, что наши тестовые функции будут названы именно так.

```python
# test_capitalize.py

def capital_case(x):
    return x.capitalize()

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'
```

Сразу бросается в глаза то, что pytest использует простой оператор `assert`, который намного проще запомнить и использовать по сравнению с многочисленными `assertSomething` функциями, присутствующими в `unittest`.

Чтобы запустить тест, перейдите в папку программы и выполните `pytest` команду:

```bash
$ pytest
```

Мы должны убедиться, что наш первый тест пройден.

Внимательный читатель заметит, что наша функция может привести к ошибке. Она не проверяет тип аргумента, чтобы убедиться, что это строка. Следовательно, если мы передадим число в качестве аргумента функции, это вызовет ошибку.

Мы хотели бы обработать этот случай в нашей функции, вызвав настраиваемое исключение с понятным сообщением об ошибке для пользователя.

Попробуем реализовать это в нашем тесте:

```python
# test_capitalize.py

import pytest

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'

def test_raises_exception_on_non_string_arguments():
    with pytest.raises(TypeError):
        capital_case(9)
```

Основным дополнением здесь является `pytest.raises` помощник, который утверждает, что наша функция должна вызывать a `TypeError` в случае, если переданный аргумент не является строкой.

Запуск тестов на этом этапе должен завершиться ошибкой со следующей ошибкой:

```python
def capital_case(x):
>       return x.capitalize()
E       AttributeError: 'int' object has no attribute 'capitalize'
```

Поскольку мы убедились, что не рассматривали такой случай, мы можем исправить это.

В нашей `capital_case` функции мы должны проверить, является ли переданный аргумент строкой или подклассом строки, прежде чем вызывать `capitalize` метод. Если это не так, мы должны создать ошибку `TypeError` с специальным сообщением об ошибке.

```python
# test_capitalize.py

def capital_case(x):
    if not isinstance(x, str):
        raise TypeError('Please provide a string argument')
      return x.capitalize()
```

Когда мы перезапустим наши тесты, они должны пройти успешно.

# Использование Pytest Fixtures

В следующих разделах мы рассмотрим некоторые более продвинутые функции pytest. Для этого нам понадобится небольшой проект.

Мы будем писать `wallet` приложение, которое позволит пользователям добавлять деньги в кошелек или тратить их. Он будет реализован как класс с двумя методами экземпляра: `spend_cash` и `add_cash`.

Мы начнем с написания наших тестов. Создайте файл с именем `test_wallet.py` в рабочем каталоге и добавьте следующее содержимое:

```python
# test_wallet.py

import pytest
from wallet import Wallet, InsufficientAmount


def test_default_initial_amount():
    wallet = Wallet()
    assert wallet.balance == 0

def test_setting_initial_amount():
    wallet = Wallet(100)
    assert wallet.balance == 100

def test_wallet_add_cash():
    wallet = Wallet(10)
    wallet.add_cash(90)
    assert wallet.balance == 100

def test_wallet_spend_cash():
    wallet = Wallet(20)
    wallet.spend_cash(10)
    assert wallet.balance == 10

def test_wallet_spend_cash_raises_exception_on_insufficient_amount():
    wallet = Wallet()
    with pytest.raises(InsufficientAmount):
        wallet.spend_cash(100)
```

Перво-наперво, мы импортируем `Wallet` класс и `InsufficientAmount` исключение, которое мы вызвается, когда пользователь пытается потратить больше денег, чем есть в его кошельке.

Когда мы инициализируем `Wallet` класс, мы ожидаем, что он будет иметь баланс по умолчанию `0`. Однако, когда мы инициализируем класс с некоторым значением, это значение должно быть установлено как начальный баланс кошелька.

Переходя к методам, которые мы планируем реализовать, мы проверяем, что `add_cash` метод правильно увеличивает баланс с добавленной суммой. С другой стороны, мы также гарантируем, что этот `spend_cash` метод уменьшит баланс на потраченную сумму и что мы не сможем потратить больше денег, чем есть в кошельке. Если мы попытаемся это сделать, должно возникнуть исключение `InsufficientAmount`.

Выполнение тестов на этом этапе должно завершиться ошибкой, поскольку мы еще не создали наш `Wallet` класс. Приступим к его созданию. Создайте файл с именем `wallet.py`, и добавим класс `Wallet`. Файл должен выглядеть следующим образом:

```python
# wallet.py

class InsufficientAmount(Exception):
    pass


class Wallet(object):

    def __init__(self, initial_amount=0):
        self.balance = initial_amount

    def spend_cash(self, amount):
        if self.balance < amount:
            raise InsufficientAmount('Not enough available to spend {}'.format(amount))
        self.balance -= amount

    def add_cash(self, amount):
        self.balance += amount
```

Прежде всего, мы определяем наше настраиваемое исключение `InsufficientAmount`, которое будет вызвано, когда мы пытаемся потратить больше денег, чем есть в кошельке. Создадим `Wallet` класс следующим образом. Конструктор принимает начальную сумму, которая по умолчанию равна `0`,если она не указана. Затем начальная сумма устанавливается как баланс.

В `spend_cash` методе мы сначала проверяем, что у нас есть достаточный баланс. Если баланс ниже суммы, которую мы собираемся потратить, мы вызываем `InsufficientAmount` исключение с дружественным сообщением об ошибке.

Далее следует реализация `add_cash` метода, который просто добавляет предоставленную сумму к текущему балансу кошелька.

Как только мы это сделаем, мы сможем перезапустить наши тесты, и они должны пройти успешно.

```bash
$ pytest -q test_wallet.py

.....
5 passed in 0.01 seconds
```

# Рефакторинг наших тестов с Fixtures

Вы могли заметить некоторые повторения, когда мы инициализировали класс в каждом тесте. Это место, где полезно использовать [python fixtures](https://docs.pytest.org/en/latest/explanation/fixtures.html?highlight=fixtures). Они помогают в создании некоторого вспомогательного кода, который должен выполняться перед некоторыми тестами, и они великолепны для создания начальной информации, необходимой для тестов.

Функции с фикстурами создаются с помощью декоратора `@pytest.fixture`. Функции тестов, которым необходимы фикстуры должны принимать их в качестве аргументов. Для примера, для теста, принимающего фикстуру с названием `wallet`, это должен быть аргумент с именем фикстуры, то есть `wallet`.

Давайте посмотрим, как это работает на практике. Мы проведем рефакторинг нашей первой версии тестов, использую фикстуры там, где они полезны.

```python
# test_wallet.py

import pytest
from wallet import Wallet, InsufficientAmount

@pytest.fixture
def empty_wallet():
    '''Returns a Wallet instance with a zero balance'''
    return Wallet()

@pytest.fixture
def wallet():
    '''Returns a Wallet instance with a balance of 20'''
    return Wallet(20)

def test_default_initial_amount(empty_wallet):
    assert empty_wallet.balance == 0

def test_setting_initial_amount(wallet):
    assert wallet.balance == 20

def test_wallet_add_cash(wallet):
    wallet.add_cash(80)
    assert wallet.balance == 100

def test_wallet_spend_cash(wallet):
    wallet.spend_cash(10)
    assert wallet.balance == 10

def test_wallet_spend_cash_raises_exception_on_insufficient_amount(empty_wallet):
    with pytest.raises(InsufficientAmount):
        empty_wallet.spend_cash(100)
```

После применения фикстур в наших тестах мы можем видеть, что мы уменьшими количество повторяющегося кода, который встречался в каждой функции тестов.

Мы определили две фикстурные функуции `wallet` и `empty_wallet`, которые выполняют инициализацию экземпляра класса  `Wallet` для тестов, где это необходимо, с различными значениями.

Для первой тестовой функции мы используем `empty_wallet` фикстуру, которая предоставляет экземпляра класса  `Wallet` с балансом, равным 0.

Следующие три теста принимают экземпляра класса  `Wallet` с балансом, равным 20. В конце, последний тест принимает `empty_wallet` фикстуру.

Перезапустим тесты, чтобы убедиться, что все работает.

Использование фикстур помогает нам исключить дублирование нашего кода. Если вы заметили случай, когда фрагмент кода многократно используется в ряде тестов, это может быть хорошим поводом для использования фикстур.

# Советы по использованию фикстур

Несколько советов по использоавнию фикстур:
- Для каждого теста фикстуры выполняются заново. То есть каждый тест будет получать от фикстур новые инициализированные объекты, которые не будут использоваться в других тестах.
- Является хорошей практикой добавлять документацию для каждой фикстуры (*docstrings*). Чтобы увидеть все доступные фикстуры, запустите в терминале следующую команду:

```bash
$ pytest --fixtures
```

Мы получили список встроенных фикстур pytest и наши собственные фикстуры.

```bash
wallet
    Returns a Wallet instance with a balance of 20
empty_wallet
    Returns a Wallet instance with a zero balance
```

# Установка параметров тестовых функций

Создав функции для тестирования отдельных методов класса `Wallet`, следующим шагом может быть тестирование работы комбинации этих методов. Для примера, мы хотим создать кошелек с начальным балансом 30, затем потратить 20, добавить 100, потратить 50. Чтобы проверить какой баланс будет на кошелке после всех манипуляций.

Как вы можете представить, процесс написания тестов для этой проверки может быть весьма утомительным, и *pytest* предоставляет достаточно изящное решение: [Parametrized test functions](https://docs.pytest.org/en/latest/how-to/parametrize.html)

Для реализации подобного тестового сценария, мы можем написать следующее:

```python
# test_wallet.py

@pytest.mark.parametrize("earned,spent,expected", [
    (30, 10, 20),
    (20, 2, 18),
])
def test_transactions(earned, spent, expected):
    my_wallet = Wallet()
    my_wallet.add_cash(earned)
    my_wallet.spend_cash(spent)
    assert my_wallet.balance == expected
```

Такой подход позволяет нам производить тестирование по определенному сценарию для разных наборов входных данных в одной функции. Мы используем декоратор `@pytest.mark.parametrize`, где мы указываем имена аргументов, которые передаются тестовой функции и список аргументов, соответсвующих этим именам.

Тестовая функция с декоратором будем запущена по одному разу для каждого набора входных данных.

Для примера, тестовая функция в первый раз будет запущена с параметрами `earned = 30`, `spent = 10`, `expected = 20`. Во второй раз функция будет запущена с параметрами, которые указаны во втором элементе списка. Все указанные параметры мы можем использовать в наших тестовых функциях.

Это весьма краткий путь для тестирования различных сценариев без повторения лишнего кода.

# Одновеременное использование фикстур и параметров для тестовой функции

Для уменьшения повторений в нашем коде, мы можем пойти еще дальше и одновременно использовать и фикстуры, и параметризацию. Для демонстрации данного подхода, давайте переместим процесс инициализации кошелька в функцию фикстуры, как мы это делали раньше.

Конечный результат будет таким:

```python
# test_wallet.py

@pytest.fixture
def my_wallet():
    '''Returns a Wallet instance with a zero balance'''
    return Wallet()

@pytest.mark.parametrize("earned,spent,expected", [
    (30, 10, 20),
    (20, 2, 18),
])
def test_transactions(my_wallet, earned, spent, expected):
    my_wallet.add_cash(earned)
    my_wallet.spend_cash(spent)
    assert my_wallet.balance == expected
```

Мы создали новую фикстуру `my_wallet`, которая абсолютно такая же, как и `empty_wallet` фикстура, которую мы создавали ранее. Новая фикстура возвращает экземпляр класса `Wallet` с нулевым балансом. Для того чтобы использовать и фикстуру и параметры в тестовой функции, мы передаем фикстуру в качестве первого аргумента и аргументы параметров остальными.

> Первод статьи [Testing Python Applications with Pytest](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest)
