# Тестирование с помощью модуля Pytest

Сегодня тестирование приложений стало стандартным навыком, необходимым для любого компетентного разработчика. Существует много пакетов Python для тестирования, и даже стандартная библиотека Python имеет хорошие инструменты для тестирования. В более крупной экосистеме Python есть множество инструментов для тестирования. Pytest выделяется среди них своей простотой использования и способностью справляться со все более сложными задачами тестирования.

В этом руководстве будет показано, как писать тесты для кода Python с помощью pytest и как использовать его для обслуживания широкого спектра сценариев тестирования.

# Пример использования

Начнем с простого теста. Pytest ожидает, что наши тесты будут расположены в файлах, имена которых начинаются `test_` или заканчиваются на `_test.py`.

Давайте создадим файл с именем `test_capitalize.py`, и внутри него мы напишем функцию с именем `capital_case`, которая должна принимать строку в качестве аргумента и должна возвращать версию строки с заглавной буквы.

Мы также напишем тест, `test_capital_case` чтобы убедиться, что функция выполняет то, что должна делать. Мы будем ставить префикс `test_` перед именами всех тестовых функций, так как pytest ожидает, что наши тестовые функции будут названы именно так.

```python
# test_capitalize.py

def capital_case(x):
    return x.capitalize()

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'
```

Сразу бросается в глаза то, что pytest использует простой оператор `assert`, который намного проще запомнить и использовать по сравнению с многочисленными `assertSomething` функциями, присутствующими в `unittest`.

Чтобы запустить тест, перейдите в папку программы и выполните `pytest` команду:

```bash
$ pytest
```

Мы должны убедиться, что наш первый тест пройден.

Внимательный читатель заметит, что наша функция может привести к ошибке. Она не проверяет тип аргумента, чтобы убедиться, что это строка. Следовательно, если мы передадим число в качестве аргумента функции, это вызовет ошибку.

Мы хотели бы обработать этот случай в нашей функции, вызвав настраиваемое исключение с понятным сообщением об ошибке для пользователя.

Попробуем реализовать это в нашем тесте:

```python
# test_capitalize.py

import pytest

def test_capital_case():
    assert capital_case('semaphore') == 'Semaphore'

def test_raises_exception_on_non_string_arguments():
    with pytest.raises(TypeError):
        capital_case(9)
```

Основным дополнением здесь является `pytest.raises` помощник, который утверждает, что наша функция должна вызывать a `TypeError` в случае, если переданный аргумент не является строкой.

Запуск тестов на этом этапе должен завершиться ошибкой со следующей ошибкой:

```python
def capital_case(x):
>       return x.capitalize()
E       AttributeError: 'int' object has no attribute 'capitalize'
```

Поскольку мы убедились, что не рассматривали такой случай, мы можем исправить это.

В нашей `capital_case` функции мы должны проверить, является ли переданный аргумент строкой или подклассом строки, прежде чем вызывать `capitalize` метод. Если это не так, мы должны создать ошибку `TypeError` с специальным сообщением об ошибке.

```python
# test_capitalize.py

def capital_case(x):
    if not isinstance(x, str):
        raise TypeError('Please provide a string argument')
      return x.capitalize()
```

Когда мы перезапустим наши тесты, они должны пройти успешно.

# Использование Pytest Fixtures

В следующих разделах мы рассмотрим некоторые более продвинутые функции pytest. Для этого нам понадобится небольшой проект.

Мы будем писать `wallet` приложение, которое позволит пользователям добавлять деньги в кошелек или тратить их. Он будет реализован как класс с двумя методами экземпляра: `spend_cash` и `add_cash`.

Мы начнем с написания наших тестов. Создайте файл с именем `test_wallet.py` в рабочем каталоге и добавьте следующее содержимое:

```python
# test_wallet.py

import pytest
from wallet import Wallet, InsufficientAmount


def test_default_initial_amount():
    wallet = Wallet()
    assert wallet.balance == 0

def test_setting_initial_amount():
    wallet = Wallet(100)
    assert wallet.balance == 100

def test_wallet_add_cash():
    wallet = Wallet(10)
    wallet.add_cash(90)
    assert wallet.balance == 100

def test_wallet_spend_cash():
    wallet = Wallet(20)
    wallet.spend_cash(10)
    assert wallet.balance == 10

def test_wallet_spend_cash_raises_exception_on_insufficient_amount():
    wallet = Wallet()
    with pytest.raises(InsufficientAmount):
        wallet.spend_cash(100)
```

Перво-наперво, мы импортируем `Wallet` класс и `InsufficientAmount` исключение, которое мы вызвается, когда пользователь пытается потратить больше денег, чем есть в его кошельке.

Когда мы инициализируем `Wallet` класс, мы ожидаем, что он будет иметь баланс по умолчанию `0`. Однако, когда мы инициализируем класс с некоторым значением, это значение должно быть установлено как начальный баланс кошелька.

Переходя к методам, которые мы планируем реализовать, мы проверяем, что `add_cash` метод правильно увеличивает баланс с добавленной суммой. С другой стороны, мы также гарантируем, что этот `spend_cash` метод уменьшит баланс на потраченную сумму и что мы не сможем потратить больше денег, чем есть в кошельке. Если мы попытаемся это сделать, должно возникнуть исключение `InsufficientAmount`.

Выполнение тестов на этом этапе должно завершиться ошибкой, поскольку мы еще не создали наш `Wallet` класс. Приступим к его созданию. Создайте файл с именем `wallet.py`, и добавим класс `Wallet`. Файл должен выглядеть следующим образом:

```python
# wallet.py

class InsufficientAmount(Exception):
    pass


class Wallet(object):

    def __init__(self, initial_amount=0):
        self.balance = initial_amount

    def spend_cash(self, amount):
        if self.balance < amount:
            raise InsufficientAmount('Not enough available to spend {}'.format(amount))
        self.balance -= amount

    def add_cash(self, amount):
        self.balance += amount
```

Прежде всего, мы определяем наше настраиваемое исключение `InsufficientAmount`, которое будет вызвано, когда мы пытаемся потратить больше денег, чем есть в кошельке. Создадим `Wallet` класс следующим образом. Конструктор принимает начальную сумму, которая по умолчанию равна `0`,если она не указана. Затем начальная сумма устанавливается как баланс.

В `spend_cash` методе мы сначала проверяем, что у нас есть достаточный баланс. Если баланс ниже суммы, которую мы собираемся потратить, мы вызываем `InsufficientAmount` исключение с дружественным сообщением об ошибке.

Далее следует реализация `add_cash` метода, который просто добавляет предоставленную сумму к текущему балансу кошелька.

Как только мы это сделаем, мы сможем перезапустить наши тесты, и они должны пройти успешно.

```bash
$ pytest -q test_wallet.py

.....
5 passed in 0.01 seconds
```

```python

```

```python

```

```python

```

```python

```

```python

```

```python

```

> Первод статьи [Testing Python Applications with Pytest](https://semaphoreci.com/community/tutorials/testing-python-applications-with-pytest)
